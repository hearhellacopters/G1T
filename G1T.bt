//------------------------------------------------
//--- 010 Editor v9.0.2 Binary Template
//
//      File: Koei Tecmo Texture Container
//   Authors: Raytwo, HealingBrew, Joschuka, HearHellacopters
//   Version: 2.4
//   Purpose: Parsing G1T texture containers
//  Category: Image
// File Mask: *.g1t
//  ID Bytes: 
//   History:
//   2.4    2025-05-01  HearHellacopters: Add new logic for reading ex headers
//   2.3    2025-04-25  HearHellacopters: Added Nintendo Switch size padding
//   2.2    2025-04-25  HearHellacopters: Fix for 0 files size error files and new enums
//   2.1    2025-04-10  HearHellacopters: Extra header ints don't generate on 0 size
//   2.0    2025-04-04  HearHellacopters: Fixed size calculations & other errors
//   1.9    2025-03-29  HearHellacopters: Fixed mips and added Ronin swizzle flag
//   1.8    2025-03-16  HearHellacopters: Added ASTC check
//   1.7    2024-12-16  HearHellacopters: Added Mac build info
//   1.6    2024-12-16  HearHellacopters: Rewrite with updated formats to enums
//   1.5    2023-11-04  HearHellacopters: Added bitsPerPixel for formats size
//   1.4    2019-11-28  HearHellacopters: Edit better looping
//   1.3    2019-11-28  Joschuka: Edit for DFFOO g1ts.
//   1.2    2019-11-28  HealingBrew: Updated MipCount, Subsystem, and Dimension logic.
//   1.1.1  2019-08-23  Raytwo: Added the normal map flag table
//   1.1    2019-09-08  Raytwo: Added support for RGBA8 internal format
//   1.0    2019-08-22  Raytwo: Made the original file
//------------------------------------------------
LittleEndian();

// Texture enums for all Window and Open GL formats
typedef enum <ushort> 
{
 // Windows DXGI ENUMS 
 // https://learn.microsoft.com/en-us/uwp/api/windows.graphics.directx.directxpixelformat
    DXGI_FORMAT_R32G32B32A32_TYPELESS                   = 0x01,
    DXGI_FORMAT_R32G32B32A32_FLOAT                      = 0x02,
    DXGI_FORMAT_R16G16B16A16_TYPELESS                   = 0x09,
    DXGI_FORMAT_R16G16B16A16_FLOAT                      = 0x0A,
    DXGI_FORMAT_R16G16B16A16_UNORM                      = 0x0B,
    DXGI_FORMAT_R32G32_TYPELESS                         = 0x0F,
    DXGI_FORMAT_R32G32_FLOAT                            = 0x10,
    DXGI_FORMAT_R32G8X24_TYPELESS                       = 0x13,
    DXGI_FORMAT_D32_FLOAT_S8X24_UINT                    = 0x14,
    DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS                = 0x15,
    DXGI_FORMAT_R10G10B10A2_UNORM                       = 0x18,
    DXGI_FORMAT_R11G11B10_FLOAT                         = 0x1A,
    DXGI_FORMAT_R8G8B8A8_TYPELESS                       = 0x1B,
    DXGI_FORMAT_R8G8B8A8_UNORM                          = 0x1C,
    DXGI_FORMAT_R8G8B8A8_UNORM_SRGB                     = 0x1D,
    DXGI_FORMAT_R8G8B8A8_UINT                           = 0x1E,
    DXGI_FORMAT_R16G16_TYPELESS                         = 0x21,
    DXGI_FORMAT_R16G16_FLOAT                            = 0x22,
    DXGI_FORMAT_R16G16_UNORM                            = 0x23,
    DXGI_FORMAT_R32_TYPELESS                            = 0x27,
    DXGI_FORMAT_D32_FLOAT                               = 0x28,
    DXGI_FORMAT_R32_FLOAT                               = 0x29,
    DXGI_FORMAT_R24G8_TYPELESS                          = 0x2C,
    DXGI_FORMAT_D24_UNORM_S8_UINT                       = 0x2D,
    DXGI_FORMAT_R24_UNORM_X8_TYPELESS                   = 0x2E,
    DXGI_FORMAT_R8G8_TYPELESS                           = 0x30,
    DXGI_FORMAT_R8G8_UNORM                              = 0x31,
    DXGI_FORMAT_R8G8_UINT                               = 0x32,
    DXGI_FORMAT_R16_TYPELESS                            = 0x35,
    DXGI_FORMAT_R16_FLOAT                               = 0x36,
    DXGI_FORMAT_D16_UNORM                               = 0x37,
    DXGI_FORMAT_R16_UNORM                               = 0x38,
    DXGI_FORMAT_R8_SINT                                 = 0x40,
    DXGI_FORMAT_A8_UNORM                                = 0x41,
    DXGI_FORMAT_BC1_TYPELESS                            = 0x46,
    DXGI_FORMAT_BC1_UNORM                               = 0x47,
    DXGI_FORMAT_BC1_UNORM_SRGB                          = 0x48,
    DXGI_FORMAT_BC2_TYPELESS                            = 0x49,
    DXGI_FORMAT_BC2_UNORM                               = 0x4A,
    DXGI_FORMAT_BC2_UNORM_SRGB                          = 0x4B,
    DXGI_FORMAT_BC3_TYPELESS                            = 0x4C,
    DXGI_FORMAT_BC3_UNORM                               = 0x4D,
    DXGI_FORMAT_BC3_UNORM_SRGB                          = 0x4E,
    DXGI_FORMAT_BC4_TYPELESS                            = 0x4F,
    DXGI_FORMAT_BC4_UNORM                               = 0x50,
    DXGI_FORMAT_BC5_TYPELESS                            = 0x52,
    DXGI_FORMAT_BC5_UNORM                               = 0x53,
    DXGI_FORMAT_B5G6R5_UNORM                            = 0x55,
    DXGI_FORMAT_B5G5R5A1_UNORM                          = 0x56,
    DXGI_FORMAT_B8G8R8A8_UNORM                          = 0x57,
    DXGI_FORMAT_B8G8R8X8_UNORM                          = 0x58,
    DXGI_FORMAT_B8G8R8A8_TYPELESS                       = 0x5A,
    DXGI_FORMAT_B8G8R8A8_UNORM_SRGB                     = 0x5B,
    DXGI_FORMAT_B8G8R8X8_TYPELESS                       = 0x5C,
    DXGI_FORMAT_B8G8R8X8_UNORM_SRGB                     = 0x5D,
    DXGI_FORMAT_BC6H_TYPELESS                           = 0x5E,
    DXGI_FORMAT_BC6H_UF16                               = 0x5F,
    DXGI_FORMAT_BC7_TYPELESS                            = 0x61,
    DXGI_FORMAT_BC7_UNORM                               = 0x62,
    DXGI_FORMAT_BC7_UNORM_SRGB                          = 0x63,
    
 // Android / iOS GL ENUMS 
 // https://registry.khronos.org/OpenGL/api/GL/glext.h
    GL_FALSE                                            = 0x0000,
    GL_RGBA                                             = 0x1908,
    GL_UNSIGNED_BYTE                                    = 0x1401,
    GL_BGRA                                             = 0x80E1,
    GL_R32F                                             = 0x822E,
    GL_RED                                              = 0x1903,
    GL_FLOAT                                            = 0x1406,
    GL_RGBA16F                                          = 0x881A,
    GL_HALF_FLOAT_OES                                   = 0x8D61,
    GL_RGBA32F                                          = 0x8814,
    GL_DEPTH_STENCIL                                    = 0x84F9,
    GL_UNSIGNED_INT_24_8                                = 0x84FA,
    GL_COMPRESSED_RGBA_S3TC_DXT1_EXT                    = 0x83F1,
    GL_COMPRESSED_RGBA_S3TC_DXT3_EXT                    = 0x83F2,
    GL_COMPRESSED_RGBA_S3TC_DXT5_EXT                    = 0x83F3,
    GL_ALPHA                                            = 0x1906,
    GL_DEPTH_COMPONENT16                                = 0x81A5,
    GL_DEPTH_COMPONENT                                  = 0x1902,
    GL_UNSIGNED_SHORT                                   = 0x1403,
    GL_R16                                              = 0x822A,
    GL_R8                                               = 0x8229,
    GL_RGB                                              = 0x1907,
    GL_UNSIGNED_SHORT_5_6_5                             = 0x8363,
    GL_UNSIGNED_SHORT_5_5_5_1                           = 0x8034,
    GL_UNSIGNED_SHORT_4_4_4_4                           = 0x8033,
    GL_R8I                                              = 0x8231,
    GL_RED_INTEGER                                      = 0x8D94,
    GL_BYTE                                             = 0x1400,
    GL_R16I                                             = 0x8233,
    GL_SHORT                                            = 0x1402,
    GL_R32I                                             = 0x8235,
    GL_INT                                              = 0x1404,
    GL_RGB10_A2                                         = 0x8059,
    GL_UNSIGNED_INT_2_10_10_10_REV_EXT                  = 0x8368,
    GL_RGBA16                                           = 0x805B,
    GL_UNSIGNED_INT                                     = 0x1405,
    GL_DEPTH_COMPONENT32F                               = 0x8CAC,
    GL_LUMINANCE                                        = 0x1909,
    GL_LUMINANCE_ALPHA                                  = 0x190A,
    GL_ETC1_RGB8_OES                                    = 0x8D64,
    GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG                 = 0x8C03,
    GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG                 = 0x8C02,
    GL_RGBA8UI                                          = 0x8D7C,
    GL_RGBA_INTEGER                                     = 0x8D99,
    GL_RG8UI                                            = 0x8238,
    GL_RG_INTEGER                                       = 0x8228,
    GL_RG16F                                            = 0x822F,
    GL_RG                                               = 0x8227,
    GL_R16F                                             = 0x822D,
    GL_R11F_G11F_B10F                                   = 0x8C3A,
    GL_UNSIGNED_INT_10F_11F_11F_REV                     = 0x8C3B,
    GL_DEPTH32F_STENCIL8                                = 0x8CAD,
    GL_FLOAT_32_UNSIGNED_INT_24_8_REV                   = 0x8DAD,
    GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG                  = 0x8C00,
    GL_COMPRESSED_RGBA8_ETC2_EAC                        = 0x9278,
    GL_RG8                                              = 0x822B,
    GL_COMPRESSED_R11_EAC                               = 0x9270,
    GL_COMPRESSED_RG11_EAC                              = 0x9272,
    GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2         = 0x9276,
    GL_COMPRESSED_RGBA_ASTC                             = 0x93AF,
    GL_COMPRESSED_RGBA_ASTC_4x4                         = 0x93B0,
    GL_COMPRESSED_RGBA_ASTC_5x4                         = 0x93B1,
    GL_COMPRESSED_RGBA_ASTC_5x5                         = 0x93B2,
    GL_COMPRESSED_RGBA_ASTC_6x5                         = 0x93B3,
    GL_COMPRESSED_RGBA_ASTC_6x6                         = 0x93B4,
    GL_COMPRESSED_RGBA_ASTC_8x5                         = 0x93B5,
    GL_COMPRESSED_RGBA_ASTC_8x6                         = 0x93B6,
    GL_COMPRESSED_RGBA_ASTC_8x8                         = 0x93B7,
    GL_COMPRESSED_RGBA_ASTC_10x5                        = 0x93B8,
    GL_COMPRESSED_RGBA_ASTC_10x6                        = 0x93B9,
    GL_COMPRESSED_RGBA_ASTC_10x8                        = 0x93BA,
    GL_COMPRESSED_RGBA_ASTC_10x10                       = 0x93BB,
    GL_COMPRESSED_RGBA_ASTC_12x10                       = 0x93BC,
    GL_COMPRESSED_RGBA_ASTC_12x12                       = 0x93BD,
    
 // Nintendo Switch ENUM for BNTX format 
 // https://code.botw.link/uking/uking/lib/NintendoSDK/include/nn/gfx/gfx_Enum.h.html#nn::gfx::ChannelFormat
    BNTX_R5G6B5_UNORM                                   =  0x0701,
    BNTX_R5G5B5A1_UNORM                                 =  0x0501,
    BNTX_R4G4B4A4_UNORM                                 =  0x0301,
    
 // Nintendo PICA 3DS 
 // https://github.com/xdanieldzd/Tharsis/blob/master/Tharsis/Images/Pica.cs
    PICA_RGBA                                           = 0x6752,
    PICA_RGB                                            = 0x6754,
    PICA_A                                              = 0x6756,
    PICA_LUMINANCE                                      = 0x6757,
    PICA_LUMINANCE_A                                    = 0x6758,
    PICA_R16                                            = 0x6759,
    PICA_ETC1_RGB8                                      = 0x675A,
    PICA_ETC1_RGB8A4                                    = 0x675B,
    PICA_UNORM_44_BYTE                                  = 0x6760,
    PICA_UNORM_4_HALF_BYTE                              = 0x6761,
    
 // Sony PS3 SEC GXM format (faked to not conflict) 
 // https://github.com/vitasdk/vita-headers/blob/master/include/psp2/gxm.h
    SCE_GXM_TEXTURE_BASE_FORMAT_U2F10F10F10             = 0x549A,
    SCE_GXM_TEXTURE_BASE_FORMAT_U4U4U4U4                = 0x5402,
    SCE_GXM_TEXTURE_BASE_FORMAT_U8U8                    = 0x5407,
    SCE_GXM_TEXTURE_BASE_FORMAT_P4                      = 0x5494,
    SCE_GXM_TEXTURE_BASE_FORMAT_P8                      = 0x5495,
    SCE_GXM_TEXTURE_BASE_FORMAT_PVRTII2BPP              = 0x5482,
    SCE_GXM_TEXTURE_BASE_FORMAT_PVRTII4BPP              = 0x5483,
    SCE_GXM_TEXTURE_SWIZZLE4_ABGR                       = 0x5500,
    SCE_GXM_TEXTURE_SWIZZLE4_ARGB                       = 0x5501,
    SCE_GXM_TEXTURE_SWIZZLE2_GRRR                       = 0x5702,
    
 // PS4 SEC format (faked to not conflict) 
 // https://github.com/Inori/GPCS4/blob/master/GPCS4/Graphics/Gnm/GnmConstant.h
    SEC_G8R8                                            = 0x5587,
    SEC_R8                                              = 0x5585,
    SEC_UNORM                                           = 0x5580,
    SEC_R16                                             = 0x5584,
    
 // Wii GX format (faked to not conflict)  
 // https://wiki.tockdom.com/wiki/Image_Formats
    GX_TF_I4                                            = 0x5A00,
    GX_TF_RGB5A3                                        = 0x5A05,
    GX_TF_CI14                                          = 0x5A0A
} TEX_ENUMS;

local TEX_ENUMS TEX_FORMS[640]<hidden=true> = 
{
 //                                   v - I added this to the table (not found in client)                                     
 // Internal|Color  |Data   |Bits per|Min byte
 // format  |space  |type   |pixel   |size
    0x1908, 0x1908, 0x1401, 0x20,    0x04, // 0x00 GL_RGBA GL_RGBA GL_UNSIGNED_BYTE
    0x80E1, 0x80E1, 0x1401, 0x20,    0x04, // 0x01 GL_BGRA GL_BGRA GL_UNSIGNED_BYTE
    0x822E, 0x1903, 0x1406, 0x20,    0x04, // 0x02 GL_R32F GL_RED GL_FLOAT
    0x881A, 0x1908, 0x8D61, 0x40,    0x08, // 0x03 GL_RGBA16F GL_RGBA GL_HALF_FLOAT_OES
    0x8814, 0x1908, 0x1406, 0x80,    0x10, // 0x04 GL_RGBA32F GL_RGBA GL_FLOAT
    0x84F9, 0x84F9, 0x84FA, 0x20,    0x04, // 0x05 GL_DEPTH_STENCIL GL_DEPTH_STENCIL GL_UNSIGNED_INT_24_8 (d24s8)
    0x83F1, 0x1908, 0x1401, 0x04,    0x08, // 0x06 GL_COMPRESSED_RGBA_S3TC_DXT1_EXT GL_RGBA GL_UNSIGNED_BYTE BC1
    0x83F2, 0x1908, 0x1401, 0x08,    0x10, // 0x07 GL_COMPRESSED_RGBA_S3TC_DXT3_EXT GL_RGBA GL_UNSIGNED_BYTE BC2
    0x83F3, 0x1908, 0x1401, 0x08,    0x10, // 0x08 GL_COMPRESSED_RGBA_S3TC_DXT5_EXT GL_RGBA GL_UNSIGNED_BYTE BC3
    0x1B,   0x1C,   0x1D,   0x20,    0x04, // 0x09 DXGI_FORMAT_R8G8B8A8_TYPELESS DXGI_FORMAT_R8G8B8A8_UNORM DXGI_FORMAT_R8G8B8A8_UNORM_SRGB
    0x5A,   0x57,   0x5B,   0x20,    0x04, // 0x0A DXGI_FORMAT_B8G8R8A8_TYPELESS DXGI_FORMAT_B8G8R8A8_UNORM DXGI_FORMAT_B8G8R8A8_UNORM_SRGB
    0x27,   0x29,   0x29,   0x20,    0x04, // 0x0B DXGI_FORMAT_R32_TYPELESS DXGI_FORMAT_R32_FLOAT DXGI_FORMAT_R32_FLOAT
    0x09,   0x0A,   0x0A,   0x40,    0x08, // 0x0C DXGI_FORMAT_R16G16B16A16_TYPELESS DXGI_FORMAT_R16G16B16A16_FLOAT DXGI_FORMAT_R16G16B16A16_FLOAT
    0x01,   0x02,   0x02,   0x80,    0x10, // 0x0D DXGI_FORMAT_R32G32B32A32_TYPELESS DXGI_FORMAT_R32G32B32A32_FLOAT DXGI_FORMAT_R32G32B32A32_FLOAT 
    0x549A, 0x5500, 0x5500, 0x20,    0x04, // 0x0E SCE_GXM_TEXTURE_BASE_FORMAT_U2F10F10F10 SCE_GXM_TEXTURE_SWIZZLE4_ABGR
    0x1906, 0x1906, 0x1401, 0x08,    0x01, // 0x0F GL_ALPHA GL_ALPHA GL_UNSIGNED_BYTE
    0x46,   0x47,   0x48,   0x04,    0x08, // 0x10 DXGI_FORMAT_BC1_TYPELESS DXGI_FORMAT_BC1_UNORM DXGI_FORMAT_BC1_UNORM_SRGB DXT1 (PSV Swizzle & sometimes flip)
    0x49,   0x4A,   0x4B,   0x08,    0x10, // 0x11 DXGI_FORMAT_BC2_TYPELESS DXGI_FORMAT_BC2_UNORM DXGI_FORMAT_BC2_UNORM_SRGB DXT2 / DXT3 (PS Vita Swizzle 4x4 & sometimes flip)
    0x4C,   0x4D,   0x4E,   0x08,    0x10, // 0x12 DXGI_FORMAT_BC3_TYPELESS DXGI_FORMAT_BC3_UNORM DXGI_FORMAT_BC3_UNORM_SRGB DXT4 / DXT5 (PS Vita Swizzle 4x4 & sometimes flip)
    0x2C,   0x2E,   0x2D,   0x20,    0x04, // 0x13 DXGI_FORMAT_R24G8_TYPELESS DXGI_FORMAT_R24_UNORM_X8_TYPELESS DXGI_FORMAT_D24_UNORM_S8_UINT
    0x81A5, 0x1902, 0x1403, 0x10,    0x02, // 0x14 GL_DEPTH_COMPONENT16 GL_DEPTH_COMPONENT GL_UNSIGNED_SHORT (r16)
    0x35,   0x38,   0x37,   0x10,    0x02, // 0x15 DXGI_FORMAT_R16_TYPELESS DXGI_FORMAT_R16_UNORM DXGI_FORMAT_D16_UNORM
    0x822A, 0x1903, 0x1403, 0x10,    0x02, // 0x16 GL_R16 GL_RED GL_UNSIGNED_SHORT
    0x35,   0x38,   0x38,   0x10,    0x02, // 0x17 DXGI_FORMAT_R16_TYPELESS DXGI_FORMAT_R16_UNORM DXGI_FORMAT_R16_UNORM
    0x41,   0x41,   0x41,   0x08,    0x01, // 0x18 DXGI_FORMAT_A8_UNORM DXGI_FORMAT_A8_UNORM DXGI_FORMAT_A8_UNORM
    0x55,   0x55,   0x55,   0x10,    0x02, // 0x19 DXGI_FORMAT_B5G6R5_UNORM DXGI_FORMAT_B5G6R5_UNORM DXGI_FORMAT_B5G6R5_UNORM
    0x56,   0x56,   0x56,   0x10,    0x02, // 0x1A DXGI_FORMAT_B5G5R5A1_UNORM DXGI_FORMAT_B5G5R5A1_UNORM DXGI_FORMAT_B5G5R5A1_UNORM
    0x5402, 0x5501, 0x5501, 0x10,    0x02, // 0x1B SCE_GXM_TEXTURE_FORMAT_U4U4U4U4_SWIZZLE4_ARGB
    0x55,   0x55,   0x55,   0x10,    0x02, // 0x1C DXGI_FORMAT_B5G6R5_UNORM DXGI_FORMAT_B5G6R5_UNORM DXGI_FORMAT_B5G6R5_UNORM
    0x56,   0x56,   0x56,   0x10,    0x02, // 0x1D DXGI_FORMAT_B5G5R5A1_UNORM DXGI_FORMAT_B5G5R5A1_UNORM DXGI_FORMAT_B5G5R5A1_UNORM
    0x5402, 0x5501, 0x5501, 0x10,    0x02, // 0x1E SCE_GXM_TEXTURE_FORMAT_U4U4U4U4_SWIZZLE4_ARGB
    0x822E, 0x1903, 0x1406, 0x20,    0x04, // 0x1F GL_R32F GL_RED GL_FLOAT
    0x27,   0x29,   0x29,   0x20,    0x04, // 0x20 DXGI_FORMAT_R32_TYPELESS DXGI_FORMAT_R32_FLOAT DXGI_FORMAT_R32_FLOAT
    0x80E1, 0x80E1, 0x1401, 0x20,    0x04, // 0x21 GL_BGRA GL_BGRA GL_UNSIGNED_BYTE
    0x5C,   0x58,   0x5D,   0x20,    0x04, // 0x22 DXGI_FORMAT_B8G8R8X8_TYPELESS DXGI_FORMAT_B8G8R8X8_UNORM DXGI_FORMAT_B8G8R8X8_UNORM_SRGB
    0x21,   0x23,   0x23,   0x20,    0x04, // 0x23 DXGI_FORMAT_R16G16_TYPELESS DXGI_FORMAT_R16G16_UNORM DXGI_FORMAT_R16G16_UNORM 
    0x21,   0x23,   0x23,   0x20,    0x04, // 0x24 DXGI_FORMAT_R16G16_TYPELESS DXGI_FORMAT_R16G16_UNORM DXGI_FORMAT_R16G16_UNORM (same as above but had a 0 bpp error)
    0x5A05, 0x5A05, 0x5A05, 0x10,    0x02, // 0x25 GX_TF_RGB5A3 GX_TF_RGB5A3 GX_TF_RGB5A3 (Wii)
    0x5587, 0x5587, 0x5580, 0x10,    0x02, // 0x26 SEC_G8R8 SEC_G8R8 SEC_UNORM
    0x5407, 0x5702, 0x5702, 0x10,    0x02, // 0x27 SCE_GXM_TEXTURE_FORMAT_U8U8_SWIZZLE2_GRRR (g8r8)
    0x5585, 0x5585, 0x5580, 0x08,    0x01, // 0x28 SEC_R8 SEC_R8 SEC_UNORM 
    0x5585, 0x5585, 0x5580, 0x08,    0x01, // 0x29 SEC_R8 SEC_R8 SEC_UNORM (dupe of 0x28 so might have another thing going on)
    0x8229, 0x1903, 0x1401, 0x08,    0x01, // 0x2A GL_R8 GL_RED GL_UNSIGNED_BYTE
    0x6757, 0x6757, 0x6761, 0x04,    0x01, // 0x2B PICA_LUMINANCE PICA_LUMINANCE PICA_UNORM_4_HALF_BYTE
    0x6757, 0x6757, 0x1401, 0x08,    0x01, // 0x2C PICA_LUMINANCE PICA_LUMINANCE GL_UNSIGNED_BYTE
    0x6758, 0x6758, 0x6760, 0x08,    0x01, // 0x2D PICA_LUMINANCE_A PICA_LUMINANCE_A PICA_UNORM_44_BYTE
    0x6758, 0x6758, 0x1401, 0x10,    0x01, // 0x2E PICA_LUMINANCE_A PICA_LUMINANCE_A GL_UNSIGNED_BYTE (either l8a8 or r8g8)
    0x5A00, 0x5A00, 0x5A00, 0x04,    0x01, // 0x2F GX_TF_I4 GX_TF_I4 GX_TF_I4
    0x5585, 0x5585, 0x5580, 0x08,    0x01, // 0x30 SCE_GXM_TEXTURE_FORMAT_U8_SWIZZLE1_111R (r8)
    0x5494, 0x5500, 0x5500, 0x04,    0x01, // 0x31 SCE_GXM_TEXTURE_FORMAT_P4_SWIZZLE4_ABGR (CI4)  (a8b8g8r8)
    0x5495, 0x5500, 0x5500, 0x08,    0x01, // 0x32 SCE_GXM_TEXTURE_FORMAT_P8_SWIZZLE4_ABGR (CI8) (a8b8g8r8)
    0x5A0A, 0x5A0A, 0x5A0A, 0x10,    0x02, // 0x33 GX_TF_CI14 GX_TF_CI14 GX_TF_CI14
    0x1907, 0x1907, 0x8363, 0x10,    0x02, // 0x34 GL_RGB GL_RGB GL_UNSIGNED_SHORT_5_6_5     b5g6r5
    0x1908, 0x1908, 0x8034, 0x10,    0x02, // 0x35 GL_RGBA GL_RGBA GL_UNSIGNED_SHORT_5_5_5_1 a1b5g5r5
    0x1908, 0x1908, 0x8033, 0x10,    0x02, // 0x36 GL_RGBA GL_RGBA GL_UNSIGNED_SHORT_4_4_4_4 a4b4g4r4
    0x5494, 0x5500, 0x5500, 0x04,    0x01, // 0x37 SCE_GXM_TEXTURE_FORMAT_P4_SWIZZLE4_ABGR (a8b8g8r8)
    0x8231, 0x8D94, 0x1400, 0x08,    0x01, // 0x38 GL_R8I GL_RED_INTEGER GL_BYTE
    0x8233, 0x8D94, 0x1402, 0x10,    0x02, // 0x39 GL_R16I GL_RED_INTEGER GL_SHORT (also seen as a Z4)
    0x8235, 0x8D94, 0x1404, 0x20,    0x04, // 0x3A GL_R32I GL_RED_INTEGER GL_INT
    0x0701, 0x0701, 0x0701, 0x10,    0x02, // 0x3B BNTX_R5G6B5_UNORM BNTX_R5G6B5_UNORM, BNTX_R5G6B5_UNORM      (found in switch)
    0x0501, 0x0501, 0x0501, 0x10,    0x02, // 0x3C BNTX_R5G5B5A1_UNORM BNTX_R5G5B5A1_UNORM BNTX_R5G5B5A1_UNORM (found in switch)
    0x0301, 0x0301, 0x0301, 0x10,    0x02, // 0x3D BNTX_R4G4B4A4_UNORM BNTX_R4G4B4A4_UNORM BNTX_R4G4B4A4_UNORM (found in switch)
    0x8233, 0x8D94, 0x1402, 0x10,    0x02, // 0x3E GL_R16I GL_RED_INTEGER GL_SHORT (likely 0x39 dupe, also seen as a Z4)
    0x8235, 0x8D94, 0x1404, 0x20,    0x04, // 0x3F GL_R32I GL_RED_INTEGER GL_INT   (likely 0x3A dupe)
    0x8059, 0x1908, 0x8368, 0x20,    0x02, // 0x40 GL_RGB10_A2 GL_RGBA GL_UNSIGNED_INT_2_10_10_10_REV
    0x805B, 0x1908, 0x1403, 0x40,    0x08, // 0x41 GL_RGBA16_EXT GL_RGBA GL_UNSIGNED_SHORT
    0x18,   0x18,   0x18,   0x20,    0x02, // 0x42 DXGI_FORMAT_R10G10B10A2_UNORM DXGI_FORMAT_R10G10B10A2_UNORM DXGI_FORMAT_R10G10B10A2_UNORM
    0x09,   0x0B,   0x0B,   0x40,    0x08, // 0x43 DXGI_FORMAT_R16G16B16A16_TYPELESS DXGI_FORMAT_R16G16B16A16_UNORM DXGI_FORMAT_R16G16B16A16_UNORM 
    0x6756, 0x6756, 0x6761, 0x04,    0x01, // 0x44 PICA_A PICA_A PICA_UNORM_4_HALF_BYTE (3DS)
    0x1907, 0x1907, 0x1401, 0x18,    0x03, // 0x45 GL_RGB GL_RGB GL_UNSIGNED_BYTE       (3DS) (PS Vita swizzle 32x32 tiles)
    0x31,   0x31,   0x31,   0x10,    0x02, // 0x46 DXGI_FORMAT_R8G8_UNORM DXGI_FORMAT_R8G8_UNORM DXGI_FORMAT_R8G8_UNORM (3DS Swizzle)
    0x675A, 0x675A, 0x1907, 0x04,    0x08, // 0x47 PICA_ETC1_RGB8 PICA_ETC1_RGB8 GL_RGB 
    0x675B, 0x675B, 0x1908, 0x04,    0x10, // 0x48 PICA_ETC1_RGB8A4 PICA_ETC1_RGB8A4 GL_RGBA (has 2 block per to account for the alpha)
    0x1907, 0x1907, 0x1401, 0x18,    0x03, // 0x49 GL_RGB GL_RGB GL_UNSIGNED_BYTE
    0x1902, 0x1902, 0x1405, 0x18,    0x03, // 0x4A GL_DEPTH_COMPONENT GL_DEPTH_COMPONENT GL_UNSIGNED_INT (r8g8b8) (also 3DS)
    0x1902, 0x1902, 0x1405, 0x18,    0x03, // 0x4B GL_DEPTH_COMPONENT GL_DEPTH_COMPONENT GL_UNSIGNED_INT (r8g8b8) (like a dupe of above)
    0x0F,   0x10,   0x10,   0x40,    0x08, // 0x4C DXGI_FORMAT_R32G32_TYPELESS DXGI_FORMAT_R32G32_FLOAT DXGI_FORMAT_R32G32_FLOAT
    0x0F,   0x10,   0x10,   0x40,    0x08, // 0x4D DXGI_FORMAT_R32G32_TYPELESS DXGI_FORMAT_R32G32_FLOAT DXGI_FORMAT_R32G32_FLOAT
    0x8CAC, 0x1902, 0x1406, 0x20,    0x04, // 0x4E GL_DEPTH_COMPONENT32F GL_DEPTH_COMPONENT GL_FLOAT (R32F)
    0x27,   0x29,   0x28,   0x20,    0x04, // 0x4F DXGI_FORMAT_R32_TYPELESS DXGI_FORMAT_R32_FLOAT DXGI_FORMAT_D32_FLOAT
    0x5482, 0x5500, 0x5500, 0x02,    0x08, // 0x50 SCE_GXM_TEXTURE_FORMAT_PVRTII2BPP_SWIZZLE4_ABGR
    0x5482, 0x5500, 0x5500, 0x02,    0x08, // 0x51 SCE_GXM_TEXTURE_FORMAT_PVRTII2BPP_SWIZZLE4_ABGR
    0x5483, 0x5500, 0x5500, 0x04,    0x08, // 0x52 SCE_GXM_TEXTURE_FORMAT_PVRTII4BPP_SWIZZLE4_ABGR
    0x5483, 0x5500, 0x5500, 0x04,    0x08, // 0x53 SCE_GXM_TEXTURE_FORMAT_PVRTII4BPP_SWIZZLE4_ABGR 
    0x1909, 0x1909, 0x1401, 0x08,    0x01, // 0x54 GL_LUMINANCE GL_LUMINANCE GL_UNSIGNED_BYTE
    0x190A, 0x190A, 0x1401, 0x10,    0x02, // 0x55 GL_LUMINANCE_ALPHA GL_LUMINANCE_ALPHA GL_UNSIGNED_BYTE (also seen as G8R8)
    0x8D64, 0x1907, 0x1401, 0x04,    0x08, // 0x56 GL_ETC1_RGB8_OES GL_RGB GL_UNSIGNED_BYTE
    0x8C03, 0x1908, 0x1401, 0x02,    0x08, // 0x57 GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG GL_RGBA GL_UNSIGNED_BYTE
    0x8C02, 0x1908, 0x1401, 0x04,    0x08, // 0x58 GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG GL_RGBA GL_UNSIGNED_BYTE
    0x83F1, 0x1908, 0x1401, 0x04,    0x08, // 0x59 GL_COMPRESSED_RGBA_S3TC_DXT1_EXT GL_RGBA GL_UNSIGNED_BYTE (BC1)
    0x83F2, 0x1908, 0x1401, 0x08,    0x10, // 0x5A GL_COMPRESSED_RGBA_S3TC_DXT3_EXT GL_RGBA GL_UNSIGNED_BYTE (BC2)
    0x83F3, 0x1908, 0x1401, 0x08,    0x10, // 0x5B GL_COMPRESSED_RGBA_S3TC_DXT5_EXT GL_RGBA GL_UNSIGNED_BYTE (BC3)
    0x4F,   0x50,   0x50,   0x04,    0x08, // 0x5C DXGI_FORMAT_BC4_TYPELESS DXGI_FORMAT_BC4_UNORM DXGI_FORMAT_BC4)_UNORM 
    0x52,   0x53,   0x53,   0x08,    0x10, // 0x5D DXGI_FORMAT_BC5_TYPELESS DXGI_FORMAT_BC5_UNORM DXGI_FORMAT_BC5_UNORM
    0x5E,   0x5F,   0x5F,   0x08,    0x10, // 0x5E DXGI_FORMAT_BC6H_TYPELESS DXGI_FORMAT_BC6H_UF16 DXGI_FORMAT_BC6H_UF16
    0x61,   0x62,   0x63,   0x08,    0x10, // 0x5F DXGI_FORMAT_BC7_TYPELESS DXGI_FORMAT_BC7_UNORM DXGI_FORMAT_BC7_UNORM_SRGB  
    0x46,   0x47,   0x48,   0x04,    0x08, // 0x60 DXGI_FORMAT_BC1_TYPELESS DXGI_FORMAT_BC1_UNORM DXGI_FORMAT_BC1_UNORM_SRGB  DXT1 (PS4 swizzle)
    0x49,   0x4A,   0x4B,   0x08,    0x10, // 0x61 DXGI_FORMAT_BC2_TYPELESS DXGI_FORMAT_BC2_UNORM DXGI_FORMAT_BC2_UNORM_SRGB  DXT2 / DXT3 (PS4 swizzle)
    0x4C,   0x4D,   0x4E,   0x04,    0x10, // 0x62 DXGI_FORMAT_BC3_TYPELESS DXGI_FORMAT_BC3_UNORM DXGI_FORMAT_BC3_UNORM_SRGB  DXT4 / DXT5 (PS4 swizzle)
    0x4F,   0x50,   0x50,   0x04,    0x08, // 0x63 DXGI_FORMAT_BC4_TYPELESS DXGI_FORMAT_BC4_UNORM DXGI_FORMAT_BC4_UNORM ATI1  (swizzled)
    0x52,   0x53,   0x53,   0x08,    0x10, // 0x64 DXGI_FORMAT_BC5_TYPELESS DXGI_FORMAT_BC5_UNORM DXGI_FORMAT_BC5_UNORM ATI2  (swizzled)
    0x5E,   0x5F,   0x5F,   0x08,    0x10, // 0x65 DXGI_FORMAT_BC6H_TYPELESS DXGI_FORMAT_BC6H_UF16 DXGI_FORMAT_BC6H_UF16      (swizzled)
    0x61,   0x62,   0x63,   0x08,    0x10, // 0x66 DXGI_FORMAT_BC7_TYPELESS DXGI_FORMAT_BC7_UNORM DXGI_FORMAT_BC7_UNORM_SRGB  (swizzled)
    0x8D7C, 0x8D99, 0x1401, 0x20,    0x04, // 0x67 GL_RGBA8UI GL_RGBA_INTEGER GL_UNSIGNED_BYTE
    0x8238, 0x8228, 0x1401, 0x10,    0x02, // 0x68 GL_RG8UI GL_RG_INTEGER GL_UNSIGNED_BYTE
    0x822F, 0x8227, 0x8D61, 0x20,    0x04, // 0x69 GL_RG16F GL_RG GL_HALF_FLOAT_OES
    0x822D, 0x1903, 0x8D61, 0x10,    0x02, // 0x6A GL_R16F GL_RED GL_HALF_FLOAT_OES
    0x8C3A, 0x1907, 0x8C3B, 0x20,    0x04, // 0x6B GL_R11F_G11F_B10F GL_RGB GL_UNSIGNED_INT_10F_11F_11F_REV
    0x8CAD, 0x1902, 0x8DAD, 0x40,    0x08, // 0x6C GL_DEPTH32F_STENCIL8 GL_DEPTH_COMPONENT GL_FLOAT_32_UNSIGNED_INT_24_8_REV (r32b8p24)
    0x13,   0x15,   0x14,   0x40,    0x08, // 0x6D DXGI_FORMAT_R32G8X24_TYPELESS DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS DXGI_FORMAT_D32_FLOAT_S8X24_UINT 
    0x5584, 0x5584, 0x5580, 0x10,    0x02, // 0x6E SEC_R16 SEC_R16 SEC_UNORM
    0x8D64, 0x1907, 0x1401, 0x04,    0x08, // 0x6F GL_ETC1_RGB8_OES GL_RGB GL_UNSIGNED_BYTE (alpha under, bpp adjusted)
    0x8C00, 0x1907, 0x1401, 0x04,    0x08, // 0x70 GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG GL_RGB GL_UNSIGNED_BYTE
    0x9278, 0x1908, 0x1401, 0x08,    0x10, // 0x71 GL_COMPRESSED_RGBA8_ETC2_EAC GL_RGBA GL_UNSIGNED_BYTE
    0x8229, 0x1903, 0x1401, 0x08,    0x01, // 0x72 GL_R8 GL_RED GL_UNSIGNED_BYTE
    0x822B, 0x8227, 0x1401, 0x10,    0x02, // 0x73 GL_RG8 GL_RG GL_UNSIGNED_BYTE
    0x1B,   0x1E,   0x1E,   0x20,    0x04, // 0x74 DXGI_FORMAT_R8G8B8A8_TYPELESS DXGI_FORMAT_R8G8B8A8_UINT DXGI_FORMAT_R8G8B8A8_UINT
    0x30,   0x32,   0x32,   0x10,    0x02, // 0x75 DXGI_FORMAT_R8G8_TYPELESS DXGI_FORMAT_R8G8_UINT DXGI_FORMAT_R8G8_UINT
    0x21,   0x22,   0x22,   0x10,    0x02, // 0x76 DXGI_FORMAT_R16G16_TYPELESS DXGI_FORMAT_R16G16_FLOAT DXGI_FORMAT_R16G16_FLOAT
    0x35,   0x36,   0x36,   0x10,    0x02, // 0x77 DXGI_FORMAT_R16_TYPELESS DXGI_FORMAT_R16_FLOAT DXGI_FORMAT_R16_FLOAT
    0x1A,   0x1A,   0x1A,   0x20,    0x04, // 0x78 DXGI_FORMAT_R11G11B10_FLOAT GL_HALF_FLOAT_OES GL_HALF_FLOAT_OES
    0x5584, 0x5584, 0x5580, 0x10,    0x02, // 0x79 SEC_R16 SEC_R16 SEC_UNORM (dupe of 0x6E so something else might be going on)
    0x9270, 0x1903, 0x1401, 0x04,    0x08, // 0x7A GL_COMPRESSED_R11_EAC GL_RED GL_UNSIGNED_BYTE
    0x9272, 0x8227, 0x1401, 0x08,    0x10, // 0x7B GL_COMPRESSED_RG11_EAC GL_RG GL_UNSIGNED_BYTE
    0x9276, 0x1908, 0x1401, 0x04,    0x08, // 0x7C GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 GL_RGBA GL_UNSIGNED_BYTE
    0x93AF, 0x1908, 0x1401, 0x01F5,  0x10, // 0x7D  ASTC uses ASTC_SUB format
    0x93AF, 0x1908, 0x1401, 0x01F5,  0x10, // 0x7E  also ASTC uses ASTC_SUB format
    0x0,    0x0,    0x0,    0x0,     0x0   // 0x7F  (unknown)
};

string FORMAT_STR(ubyte num, uint astc)
{
    switch(num)
    {
    case 0x00: return "R8G8B8A8";
    case 0x01: return "B8G8R8A8";
    case 0x02: return "R32_FLOAT";
    case 0x03: return "R16G16B16A16_HALF_FLOAT";
    case 0x04: return "R32G32B32A32_FLOAT";
    case 0x05: return "D24S8";
    case 0x06: return "BC1";
    case 0x07: return "BC2";
    case 0x08: return "BC3";
    case 0x09: return "R8G8B8A8";
    case 0x0A: return "B8G8R8A8";
    case 0x0B: return "R32_FLOAT";
    case 0x0C: return "R16G16B16A16_HALF_FLOAT";
    case 0x0D: return "R32G32B32A32_FLOAT";
    case 0x0E: return "A2B10G10R10_HALF_FLOAT";
    case 0x0F: return "A8";
    case 0x10: return "BC1";
    case 0x11: return "BC2";
    case 0x12: return "BC3";
    case 0x13: return "D24S8";
    case 0x14: return "D16";
    case 0x15: return "R16";
    case 0x16: return "R16";
    case 0x17: return "R16";
    case 0x18: return "A8";
    case 0x19: return "B5G6R5";
    case 0x1A: return "B5G5R5A1";
    case 0x1B: return "A4R4G4B4";
    case 0x1C: return "B5G6R5";
    case 0x1D: return "B5G5R5A1";
    case 0x1E: return "A4R4G4B4";
    case 0x1F: return "R32_FLOAT";
    case 0x20: return "D24S8";
    case 0x21: return "B8G8R8A8";
    case 0x22: return "B8G8R8x8";
    case 0x23: return "R16G16";
    case 0x24: return "G16R16";
    case 0x25: return "R5G5B5A3";
    case 0x26: return "G8B8";
    case 0x27: return "A8R8";
    case 0x28: return "B8";
    case 0x29: return "G8";
    case 0x2A: return "R8";
    case 0x2B: return "L4";
    case 0x2C: return "L8";
    case 0x2D: return "A4L4";
    case 0x2E: return "R8A8";
    case 0x2F: return "R4";
    case 0x30: return "R8";
    case 0x31: return "CI4";
    case 0x32: return "CI8";
    case 0x33: return "C14X2";
    case 0x34: return "B5G6R5";
    case 0x35: return "A1B5G5R5";
    case 0x36: return "A4B4G4R4";
    case 0x37: return "P4";
    case 0x38: return "P8";
    case 0x39: return "R16I";
    case 0x3A: return "R32I";
    case 0x3B: return "R5G6B5";
    case 0x3C: return "R5G5B5A1";
    case 0x3D: return "R4G4B4A4";
    case 0x3E: return "R16I";
    case 0x3F: return "R32I";
    case 0x40: return "R10G10B10A2";
    case 0x41: return "R16G16B16A16";
    case 0x42: return "R10G10B10A2";
    case 0x43: return "R16G16B16A16";
    case 0x44: return "A4";
    case 0x45: return "R8G8B8";
    case 0x46: return "R8G8";
    case 0x47: return "PICA_ETC1_R8G8B8";
    case 0x48: return "PICA_ETC1_R8G8B8A4";
    case 0x49: return "R8G8B8";
    case 0x4A: return "R8G8B8";
    case 0x4B: return "R8G8B8";
    case 0x4C: return "R32G32_FLOAT";
    case 0x4D: return "R32G32_FLOAT";
    case 0x4E: return "R32_FLOAT";
    case 0x4F: return "D32_FLOAT";
    case 0x50: return "PVRTC2BPP";
    case 0x51: return "PVRTC2BPP";
    case 0x52: return "PVRTC4BPP";
    case 0x53: return "PVRTC4BPP";
    case 0x54: return "L8";
    case 0x55: return "L8A8";
    case 0x56: return "ETC1_R8G8B8";
    case 0x57: return "PVRTC2BPP";
    case 0x58: return "PVRTC4BPP";
    case 0x59: return "BC1";
    case 0x5A: return "BC2";
    case 0x5B: return "BC3";
    case 0x5C: return "BC4";
    case 0x5D: return "BC5";
    case 0x5E: return "BC6H";
    case 0x5F: return "BC7";
    case 0x60: return "BC1";
    case 0x61: return "BC2";
    case 0x62: return "BC3";
    case 0x63: return "BC4";
    case 0x64: return "BC5";
    case 0x65: return "BC6H";
    case 0x66: return "BC7";
    case 0x67: return "R8G8B8A8";
    case 0x68: return "R8G8";
    case 0x69: return "R16G16_HALF_FLOAT";
    case 0x6A: return "R16_HALF_FLOAT";
    case 0x6B: return "R11G11B10_HALF_FLOAT";
    case 0x6C: return "D32S8x24_FLOAT";
    case 0x6D: return "R16";
    case 0x6E: return "R16";
    case 0x6F: return "ETC1_R8G8B8_ALPHA_ATLAS";
    case 0x70: return "PVRTC4BPP_ALPHA_ATLAS";
    case 0x71: return "ETC2_R8G8BA8";
    case 0x72: return "R8";
    case 0x73: return "R8G8";
    case 0x74: return "R8G8B8A8";
    case 0x75: return "R8G8";
    case 0x76: return "R16G16_FLOAT";
    case 0x77: return "R16_FLOAT";
    case 0x78: return "R11G11B10_HALF_FLOAT";
    case 0x79: return "R16";
    case 0x7A: return "ETC2_EAC_R11";
    case 0x7B: return "ETC2_EAC_R11G11";
    case 0x7C: return "ETC2_R8G8B8A1";
    case 0x7D:
    case 0x7E:
        if(astc != -1)
        {
            return ASTC_STR(astc);
        }
        return "ASTC";  
    default: return Str("Unkown format %d", num);
    }
}

local ushort ASTC_SUB[70]<hidden=true> = 
{
 // Internal|Color  |Data   |Bits per|Min byte
 // format  |space  |type   |pixel   |size
    0x93B0, 0x1908, 0x1401, 0x0008,  0x10, // 0x00 GL_COMPRESSED_RGBA_ASTC_4x4    GL_RGBA  GL_UNSIGNED_BYTE 8.00
    0x93B1, 0x1908, 0x1401, 0x0628,  0x10, // 0x01 GL_COMPRESSED_RGBA_ASTC_5x4    GL_RGBA  GL_UNSIGNED_BYTE 6.40
    0x93B2, 0x1908, 0x1401, 0x050C,  0x10, // 0x02 GL_COMPRESSED_RGBA_ASTC_5x5    GL_RGBA  GL_UNSIGNED_BYTE 5.12
    0x93B3, 0x1908, 0x1401, 0x041B,  0x10, // 0x03 GL_COMPRESSED_RGBA_ASTC_6x5    GL_RGBA  GL_UNSIGNED_BYTE 4.27
    0x93B4, 0x1908, 0x1401, 0x0338,  0x10, // 0x04 GL_COMPRESSED_RGBA_ASTC_6x6    GL_RGBA  GL_UNSIGNED_BYTE 3.56
    0x93B5, 0x1908, 0x1401, 0x0314,  0x10, // 0x05 GL_COMPRESSED_RGBA_ASTC_8x5    GL_RGBA  GL_UNSIGNED_BYTE 3.20
    0x93B6, 0x1908, 0x1401, 0x0243,  0x10, // 0x06 GL_COMPRESSED_RGBA_ASTC_8x6    GL_RGBA  GL_UNSIGNED_BYTE 2.67
    0x93B7, 0x1908, 0x1401, 0x0002,  0x10, // 0x07 GL_COMPRESSED_RGBA_ASTC_8x8    GL_RGBA  GL_UNSIGNED_BYTE 2.00
    0x93B8, 0x1908, 0x1401, 0x020D,  0x10, // 0x08 GL_COMPRESSED_RGBA_ASTC_10x5   GL_RGBA  GL_UNSIGNED_BYTE 2.56
    0x93B9, 0x1908, 0x1401, 0x0100,  0x10, // 0x09 GL_COMPRESSED_RGBA_ASTC_10x6   GL_RGBA  GL_UNSIGNED_BYTE 2.13
    0x93BA, 0x1908, 0x1401, 0x013C,  0x10, // 0x0A GL_COMPRESSED_RGBA_ASTC_10x8   GL_RGBA  GL_UNSIGNED_BYTE 1.60
    0x93BB, 0x1908, 0x1401, 0x011C,  0x10, // 0x0B GL_COMPRESSED_RGBA_ASTC_10x10  GL_RGBA  GL_UNSIGNED_BYTE 1.28
    0x93BC, 0x1908, 0x1401, 0x0107,  0x10, // 0x0C GL_COMPRESSED_RGBA_ASTC_12x10  GL_RGBA  GL_UNSIGNED_BYTE 1.07
    0x93BD, 0x1908, 0x1401, 0x01F5,  0x10  // 0x0D GL_COMPRESSED_RGBA_ASTC_12x12  GL_RGBA  GL_UNSIGNED_BYTE 0.89
};

typedef enum <uint> 
{
    ASTC_4x4,
    ASTC_5x4,
    ASTC_5x5,
    ASTC_6x5,
    ASTC_6x6,
    ASTC_8x5,
    ASTC_8x6,
    ASTC_8x8,
    ASTC_10x5,
    ASTC_10x6,
    ASTC_10x8,
    ASTC_10x10,
    ASTC_12x10,
    ASTC_12x12
} eASTC_FORMAT;

string ASTC_STR(eASTC_FORMAT FORMAT) 
{
    switch(FORMAT)
    {
    case ASTC_4x4:   return "ASTC_4x4";
    case ASTC_5x4:   return "ASTC_5x4";
    case ASTC_5x5:   return "ASTC_5x5";
    case ASTC_6x5:   return "ASTC_5x6";
    case ASTC_6x6:   return "ASTC_6x6";
    case ASTC_8x5:   return "ASTC_8x5";
    case ASTC_8x6:   return "ASTC_8x6";
    case ASTC_8x8:   return "ASTC_8x8";
    case ASTC_10x5:  return "ASTC_10x5";
    case ASTC_10x6:  return "ASTC_10x6";
    case ASTC_10x8:  return "ASTC_10x8";
    case ASTC_10x10: return "ASTC_10x10";
    case ASTC_12x10: return "ASTC_12x12";
    case ASTC_12x12: return "ASTC_12x12";
    default:         return "Unknown ASTC format";
    }
}

typedef enum<uint32> 
{
    PS2      = 0x00, // <- didn't find a game with g1t files
    PS3      = 0x01, // Special Tiled Z Morton Swizzling
    X360     = 0x02, // Extra Special Tiling Swizzling
    NWii     = 0x03, // 
    NDS      = 0x04, // <- didn't find a game with g1t files
    N3DS     = 0x05, // 
    PSVita   = 0x06, // 
    Android  = 0x07, // 
    iOS      = 0x08, // 
    NWiiU    = 0x09, // Big Endian
    WinMac   = 0x0A, // They share the same enum
    PS4      = 0x0B, // Special Z Morton Swizzling
  //XOne     = 0x0C, // <- Need rom to confrim
  //???      = 0x0D, //
    WinDX12  = 0x0E, // 
  //???      = 0x0F, //
    NSwitch  = 0x10, // 
  //???      = 0x11, //
  //???      = 0x12, //
    PS5      = 0x13, //
} PLATFORM;

string SYSTEM_STR(PLATFORM SYSTEM) 
{
    switch(SYSTEM)
    {
    case PS2:     return "PS2";    
    case PS3:     return "PS3";
    case X360:    return "Xbox 360";
    case NWii:    return "Nintendo Wii";
    case NDS:     return "Nintendo DS";    
    case N3DS:    return "Nintendo 3DS";   
    case PSVita:  return "Playstation Vita";  
    case Android: return "Android"; 
    case iOS:     return "iOS";
    case NWiiU:   return "Nintendo Wii U";
    case WinMac:  return "Windows";  
    case PS4:     return "PS4";          
    case WinDX12: return "Windows Direct-X 12";       
    case NSwitch: return "Nintendo Switch";      
    case PS5:     return "PS5";
    default:      return Str("Unknown System 0x%02X", SYSTEM);
    }
}

typedef enum<ushort>
{
 // These are sometime directly hardcoded to the client.
 // Meaning that they don't appear in the file, 
 // but are hardcodes on every g1t the game reads
    CHANNEL_SWAP        = 0x01, // xbox 360 can mean dont swizzle in others
    NO_ALPHA            = 0x02, // xbox 360
    NORMAL_MAP          = 0x03, // xbox 360
    COLOR_TEST          = 0x04, // n switch test file
    N3DS_Wii_SWIZZLE    = 0x05,
    WiiU_SWIZZLE        = 0x06,
    PS4_PLANE_ARRAY     = 0x07,
    PSVITA_PS5_SWIZZLE  = 0x08,
  //???                 = 0x09,
  //???                 = 0x0A,
  //???                 = 0x0B,
  //???                 = 0x0C,
  //???                 = 0x0D,
  //???                 = 0x0E,
  //???                 = 0x0F,
  //???                 = 0x10,
  //???                 = 0x11,
  //???                 = 0x12,
  //???                 = 0x13,
  //???                 = 0x14,
    ASTC_TYPE           = 0x15
} TEX_EX_TYPE;

string TEX_EX_STR(TEX_EX_TYPE num) 
{
    switch(num)
    {
    case 0:                  return "NONE";
    case CHANNEL_SWAP:       return "CHANNEL_SWAP";
    case NO_ALPHA:           return "NO_ALPHA";
    case NORMAL_MAP:         return "NORMAL_MAP";
    case COLOR_TEST:         return "COLOR_TEST";
    case N3DS_Wii_SWIZZLE:   return "N3DS_Wii_SWIZZLE";
    case WiiU_SWIZZLE:       return "WiiU_SWIZZLE";
    case PS4_PLANE_ARRAY:    return "PS4_PLANE_ARRAY";
    case PSVITA_PS5_SWIZZLE: return "PSVITA_PS5_SWIZZLE";
    case ASTC_TYPE:          return "ASTC_TYPE";
    default:                 return "";
    }
};

enum<ubyte> S_GT1_LOAD_TYPE
{
    PLANAR      = 0,
    CUBE        = 1, // 6 sided
    VOLUME      = 2, // AKA 3D
    PLANE_ARRAY = 3, // AKA 2D array
    CUBE_ARRAY  = 4  // ver 63 and above
};

string LOAD_TYPE_STR(S_GT1_LOAD_TYPE TYPE)
{
    switch(TYPE)
    {
    case PLANAR: 
        return "";
        break;     
    case CUBE:    
        return " CUBE";
        break; 
    case VOLUME: 
        return " VOLUME";
        break;    
    case PLANE_ARRAY:
        return " PLANE ARRAY";
        break;
    case CUBE_ARRAY: 
        return " CUBE ARRAY";
        break;
    default:
        return " Unknown Type";
        break;
    }
};

enum<ubyte> COLOR_SPACE
{
    sRGB         = 0x01,
};

string COLOR_SPACE_STR(int num)
{
    switch(num)
    {
    case 0:  
        return "";
        break;  
    case 1: 
        return " (sRGB)";
        break;     
    default:
        return Str(" Unknown Color Space %d", num);
        break;
    }
};

enum<ubyte> EX_SWIZZLE_TYPE
{
    DX12_64kb = 0x01,
};

string EX_SWIZZLE_STR(int num)
{
    switch(num)
    {
    case 0:  
        return "";
        break;  
    case DX12_64kb: 
        return " (DX12 64kb swizzle)";
        break;     
    default:
        return Str(" Unknown EX Swizzle %d", num);
        break;
    }
}

   // Function for ASTC bit size
float MakeBBP(short value) 
{
 // special function that can convert a short to a float
    if (value > 255) 
    {
     // Extract high byte (whole part) and low byte (decimal part)
        local int wholePart = (value >> 8) & 0xFF;       // Most significant byte
        local byte decimalPart = value & 0xFF;           // Least significant byte

     // Combine into a float (decimal part scaled to two decimal places)
        return wholePart + (decimalPart / 100.0f);
    } 
    else 
    {
     // For values <= 255, just return as a float
        return (float)(value);
    }
}

uint32 Align(uint32 value, uint32 alignment) {
    return (value + alignment - 1) & ~(alignment - 1);
}

uint32 TextureSizeWithMips(
    uint32 width, 
    uint32 height, 
    uint32 depth,
    uint32 mipCount,
    uint32 arrayCount, 
    uint32 faceCount,
    uint32 blockByteSize, 
    uint32 blockWidth, 
    uint32 blockHeight,
    uint32 bCompressedFormat, 
    float bitsPerPixel,
    uint32 pAlignment
    )
{
    local uint32 totalSize = 0;
    local uint32 w = width;
    local uint32 h = height;
    local uint32 d = depth; if (d == 0) d = 1;
    local uint32 mip = 0;
    local uint32 blocksX = 0;
    local uint32 blocksY = 0;
    local uint32 mipSize = 0;

    for (mip = 0; mip < mipCount; ++mip)
    {
        mipSize = 0;
        w = width  >> mip; if (w == 0) w = 1;
        h = height >> mip; if (h == 0) h = 1;
        d = depth  >> mip; if (d == 0) d = 1;
        
        if(bCompressedFormat)
        {
            blocksX = (w + blockWidth - 1) / blockWidth;   if (blocksX == 0) blocksX = 1;
            blocksY = (h + blockHeight - 1) / blockHeight; if (blocksY == 0) blocksY = 1;
        
            mipSize = blocksX * blocksY * blockByteSize;
            
         // Sanity check for smallest block size
            if(mipSize < blockByteSize)
            {
                mipSize = blockByteSize;
            }
            
            if(pAlignment)
            {
                mipSize = Align(mipSize, pAlignment);
            }
            
            mipSize = mipSize * d;
            
            totalSize += mipSize;
        }
        else
        {
	        mipSize = (w * h) * (bitsPerPixel / 8);
            
         // Sanity check for smallest pixel size
            if (mipSize < blockByteSize) 
            {
                mipSize = blockByteSize;
            }  
            
            if(pAlignment)
            {
                mipSize = Align(mipSize, pAlignment);
            }
            
            mipSize = mipSize * d;
                
	        totalSize += mipSize;
        }
    }
    
    return totalSize * arrayCount * faceCount;
}

uint32 isPowerOfTwo(int n) {
  if (n <= 0) {
    return 0;
  }
  return (n & (n - 1)) == 0;
}

uint32 nextPowerOfTwo(uint32 v) {
    if (v == 0) return 1;
    v--;
    v |= v >> 1;
    v |= v >> 2;
    v |= v >> 4;
    v |= v >> 8;
    v |= v >> 16;
    v++;
    return v;
}

uint32 alignUp(uint32 value, uint32 alignment) {
    return (value + alignment - 1) & ~(alignment - 1);
}

uint32 block_height_enum(uint32 blocksY) {
    local uint32 h = blocksY + (blocksY / 2);
    if (h >= 128) return 16;
    if (h >= 64) return 8;
    if (h >= 32) return 4;
    if (h >= 16) return 2;
    return 1;
}

uint32 mip_block_height(uint32 mipHeight, uint32 blockHeightEnum) {
    while (mipHeight <= (blockHeightEnum / 2) * 8 && blockHeightEnum > 1) {
        blockHeightEnum /= 2;
    }
    return blockHeightEnum;
}

uint32 align_layer_size(uint32 layer_size, uint32 height, uint32 depth, uint32 block_height_enum) {
    local uint32 gob_height = block_height_enum;
    local uint32 gob_depth = 1;

    while (height <= (gob_height / 2) * 8 && gob_height > 1) {
        gob_height /= 2;
    }
    while (depth <= (gob_depth / 2) && gob_depth > 1) {
        gob_depth /= 2;
    }

    local uint32 block_of_gobs_size = gob_height * gob_depth * 512; // GOB_SIZE
    local uint32 size_in_blocks = layer_size / block_of_gobs_size;

    if (layer_size != size_in_blocks * block_of_gobs_size) {
        layer_size = (size_in_blocks + 1) * block_of_gobs_size;
    }

    return layer_size;
}

uint32 swizzled_mip_size(uint32 blocksX, uint32 blocksY, uint32 blocksZ,
                                 uint32 blockHeightEnum, uint32 blockSizeBytes) {
    local uint32 width_in_gobs = alignUp(blocksX * blockSizeBytes, 64) / 64;
    local uint32 height_in_gobs = (blocksY + (blockHeightEnum * 8 - 1)) / (blockHeightEnum * 8);
    return width_in_gobs * height_in_gobs * blocksZ * blockHeightEnum * 512; // GOB_SIZE
}

uint SwitchTextureSizeWithMips(
    uint32 width, 
    uint32 height, 
    uint32 depth,
    uint32 mipCount, 
    uint32 layers,
    uint32 blockWidth, 
    uint32 blockHeight,
    uint32 blockSizeBytes, 
    uint32 bitsPerPixel,
    int isCompressed,
    S_GT1_LOAD_TYPE textureType)
{
    local uint32 layerSize = 0;
    local uint32 mip = 0;
    local uint32 mipWidth = 0;
    local uint32 mipHeight = 0;
    local uint32 mipDepth = 0;
    local uint32 mipSize = 0;
    local uint32 blocksX = 0;
    local uint32 blocksY = 0;
    local uint32 blocksZ = 0;
    local uint32 mipBlockHeight = 0;
    
    local uint32 blocksY_full = (height + blockHeight - 1) / blockHeight;
    local uint32 blockHeightEnum = block_height_enum(blocksY_full);
    
    for (mip = 0; mip < mipCount; ++mip) 
    {
        mipSize = 0;

        if (isCompressed) 
        {
            mipWidth = width  >> mip;
            mipHeight = height >> mip;
            mipDepth = depth  >> mip;
    
            if (mipWidth == 0) mipWidth = 1;
            if (mipHeight == 0) mipHeight = 1;
            if (mipDepth == 0) mipDepth = 1;
        
            blocksX = (mipWidth  + blockWidth  - 1) / blockWidth;
            blocksY = (mipHeight + blockHeight - 1) / blockHeight;
            blocksZ = (mipDepth  + 1 - 1); // Assume blockDepth = 1

            mipBlockHeight = mip_block_height(blocksY, blockHeightEnum);
            mipSize = swizzled_mip_size(blocksX, blocksY, blocksZ, mipBlockHeight, blockSizeBytes);
        } 
        else 
        {
            if(mip == 0 && height < 8 ) height = 8;
            
            mipWidth = width  >> mip;
            mipHeight = height >> mip; 
            mipDepth = depth  >> mip;
    
            if (mipWidth == 0) mipWidth = 1;
            if (mipHeight == 0) mipHeight = 1;
            if (mipDepth == 0) mipDepth = 1;
            
            mipSize = (mipWidth * mipHeight * mipDepth * bitsPerPixel) / 8;
        }

        layerSize += mipSize;
    }

    // Apply 4KB alignment for 2D arrays, cubes, cube arrays
    if (textureType == PLANE_ARRAY || 
        textureType == CUBE || 
        textureType == CUBE_ARRAY
    )
    {
        layerSize = align_layer_size(layerSize, height, depth, blockHeightEnum);
    }
    
    local uint32 totalLayers = layers;
    
    if ( textureType == CUBE || 
         textureType == CUBE_ARRAY
    )
    {
        totalLayers *= 6; // 6 faces per cube
    }

    return layerSize * totalLayers;
};

local int32 PS5MipMatrixXSq[156]<hidden=true> = 
{
// (mip * 13) width dim
//      0   1   2   3   4    5    6    7    8    9    10    11    12 
/*0 */  0, 16, 16, 16, 16,  32,  64, 128, 256, 512, 1024, 2048, 4096,
/*1 */  0, 16, 16, 16, 16,  32,  64, 128, 256, 512, 1024, 2048,    0,    
/*2 */  0,  0, 16, 16, 16,  32,  64, 128, 256, 512, 1024,    0,    0,
/*3 */  0,  0, 16, 16, 16,  32, 128, 256, 256, 512,    0,    0,    0,
/*4 */  0,  0, 16, 16, 16,  64, 128, 128, 256,   0,    0,    0,    0,
/*5 */  0,  0, 16, 16, 64, 128, 128, 128,   0,   0,    0,    0,    0,
/*6 */  0, 32, 16, 32, 64,  64, 128,   0,   0,   0,    0,    0,    0,
/*7 */  0, 32, 16, 32, 64,  64,   0,   0,   0,   0,    0,    0,    0,
/*8 */  0, 32, 32, 32, 64,   0,   0,   0,   0,   0,    0,    0,    0,
/*9 */  0, 64, 16, 32,  0,   0,   0,   0,   0,   0,    0,    0,    0,
/*10*/  0, 32, 16,  0,  0,   0,   0,   0,   0,   0,    0,    0,    0,
/*11*/  0, 32,  0,  0,  0,   0,   0,   0,   0,   0,    0,    0,    0
};

local int32 PS5MipMatrixYSq[156]<hidden=true> = 
{
// (mip * 13) + hight dim 
//      0   1   2   3   4    5    6    7    8    9    10    11    12 
/*0 */  0, 16, 16, 16, 16,  32,  64, 128, 256, 512, 1024, 2048, 4096,
/*1 */  0, 16, 16, 16, 16,  32,  64, 128, 256, 512, 1024, 2048,    0,
/*2 */  0,  0, 16, 16, 16,  64,  64, 256, 256, 512, 1024,    0,    0,
/*3 */  0,  0, 16, 16, 32,  64, 128, 128, 256, 512,    0,    0,    0,
/*4 */  0,  0, 16, 16, 32, 128, 128, 256, 256,   0,    0,    0,    0,
/*5 */  0,  0, 16, 16, 64,  64, 128, 256,   0,   0,    0,    0,    0,
/*6 */  0, 32, 16, 64, 64, 128, 128,   0,   0,   0,    0,    0,    0,
/*7 */  0, 32, 32, 32, 64, 128,   0,   0,   0,   0,    0,    0,    0,
/*8 */  0, 48, 16, 64, 64,   0,   0,   0,   0,   0,    0,    0,    0,
/*9 */  0, 40, 32, 64,  0,   0,   0,   0,   0,   0,    0,    0,    0,
/*10*/  0, 48, 32,  0,  0,   0,   0,   0,   0,   0,    0,    0,    0,
/*11*/  0, 48,  0,  0,  0,   0,   0,   0,   0,   0,    0,    0,    0
};

// never figured out the map on none-squares so I gave up here
uint32 PS5TextureSizeWithMips(
    uint32 widthDim, 
    uint32 heightDim, 
    uint32 depth,
    uint32 mipCount,
    uint32 planeCount, 
    uint32 faceCount,
    uint32 blockSize, 
    uint32 blockWidth, 
    uint32 blockHeight,
    uint32 bCompressedFormat, 
    float bitsPerPixel,
    uint64 totalTexBufferLen
    )
{
    local uint32 totalSize = 0;
    local int32 w = widthDim;
    local int32 h = heightDim;
    local uint32 dimX = widthDim;
    local uint32 dimY = heightDim;
    local uint32 d = depth; if (d == 0) d = 1;
    local uint32 mip = 0;
    local uint32 mip0Size = 0;
    local uint32 mipSize = 0;

    local uint32 pad = 0x40;
    if (bitsPerPixel < 8 && heightDim > widthDim) pad = 0x80;
    if (bitsPerPixel > 8)
    {
        pad = 0x20;
        if (heightDim > widthDim) pad = 0x40;
    }
    
    for (mip = 0; mip <= mipCount; ++mip)
    {
        mipSize = 0;
        d = depth  >> mip; if (d == 0) d = 1; 
        
        // only worked when square power of 2
        dimX = PS5MipMatrixXSq[(mip * 13) + w];
        dimY = PS5MipMatrixYSq[(mip * 13) + h];
        
        if (bCompressedFormat) 
        {
        
            dimX = (dimX + blockWidth - 1) / blockWidth;   
            dimY = (dimY + blockHeight - 1) / blockHeight;
            
            mipSize = (dimX * dimY) * blockSize;
        }
        else
        {
            mipSize = (dimX * dimY) * (bitsPerPixel / 8);
        }
        
        if(mip == 0)
        {
            mip0Size = mipSize;
        }
        
        mipSize = mipSize * d;
        
        totalSize += mipSize;
        
        --w; if( w < 0 ) w = 0;
        --h; if( h < 0 ) h = 0;
    }
    
    return totalSize * planeCount * faceCount;
}

typedef struct 
{
    local uint start<hidden=true> = FTell();
    TEX_EX_TYPE TYPE<fgcolor=cAqua>;
    ubyte  COUNT<bgcolor=cBlack>; 
    ubyte  RESERVED_CONSUMED<fgcolor=cYellow, comment="System writes a 1 here once the extras have been consumed">;
    local int CONSUMED = 0;
    local uint64 ARRAY_DEPTH = 1;
    local string str<hidden=true>;
 // 21 ASTC table
    if (TYPE == ASTC_TYPE && COUNT == 1) 
    {   
        eASTC_FORMAT KT_ASTC_FORMAT<fgcolor=cAqua>;
        str = ASTC_STR(KT_ASTC_FORMAT);
    } 
    else if ((TYPE == WiiU_SWIZZLE || TYPE == N3DS_Wii_SWIZZLE) && COUNT == 1) 
    { 
        uint Wii_SWIZZLE<fgcolor=cAqua>;
        str = Str("WiiU_SWIZZLE %d", Wii_SWIZZLE);
    }
    else if(TYPE == PS4_PLANE_ARRAY && COUNT == 32)
    {   
     // unsure what this is, Vector bases?
        uint ID1;
        float FLOAT1[4];
        uint ID2;
        float FLOAT2[4];
        uint ID3;
        float FLOAT3[5];
        uint ID4;
        float FLOAT4[4];
        uint ID5;
        float FLOAT5[4];
        uint ID6;
        float FLOAT6[5];
        // I have no idea what this is
        if(ID1 == 922948206) // also seen 922948207 but not the same depth
        {
            ARRAY_DEPTH = 2;
        }
        str = Str("PS4_PLANE_ARRAY %d", ID1);
    } 
    else if(COUNT != 0)
    {
     // unsure at the moment how this other data is used
        uint EXTRA_INTS[COUNT]<comment="Sometimes used as KIDs">;
        str = Str("0x%02X - %s x%d", TYPE, TEX_EX_STR(TYPE), COUNT);
    }
    else
    {
        str = Str("0x%02X - %s x%d", TYPE, TEX_EX_STR(TYPE), COUNT);
    }
} S_G1T_HEADER_EX<read=this.str, fgcolor=cLtBlue, optimize=false>;

struct ktgl 
{
    local uint8 bBigEndian<hidden=true> = false;
 // Magic check
    if(ReadUInt() == 0x47543147)
    {
        BigEndian();
        bBigEndian = true;
    }
    if( !(ReadUInt() == 0x47543147 || 
        ReadUInt() == 0x47315447)
    )
    {
        Assert(0 && "Not a G1TG file");
    }
    
    local uint64 FileStart<hidden=true> = FTell();    
    
    struct 
    {
        struct 
        {
            uint FULL_MAGIC<hidden=true>; 
            local char MAGIC[4] ={
                (FULL_MAGIC >> 24 ) & 0xFF,
                (FULL_MAGIC >> 16 ) & 0xFF,
                (FULL_MAGIC >> 8  ) & 0xFF,
                 FULL_MAGIC         & 0xFF
            }; 
            uint VERSION;
            local uint VERSION_NUMBER = 
            (((VERSION >> 24) & 0xFF) - 0x30) * 1000 +
            (((VERSION >> 16) & 0xFF) - 0x30) * 100+
            (((VERSION >> 8 ) & 0xFF) - 0x30) * 10+
              (VERSION        & 0xFF) - 0x30;        
        } MAGICS<bgcolor=cDkRed>;
        uint32 FILE_SIZE<bgcolor=cBlack>;
        uint32 TEX_OFFSET<comment="Offset table address", bgcolor=cLtRed>;
        uint32 TEX_COUNT<comment="Number of textures", bgcolor=cLtGreen, fgcolor=cWhite>;
        local int HEADER_SIZE = 20;
        if (MAGICS.VERSION_NUMBER < 30)
        {
         // hard codes SYSTEM to 0;
         // No S_G1T_HEADER_EX
            local PLATFORM SYSTEM = 0;
            local uint HEADER_EX_SIZE = 0;
            FSkip(4);
        } 
        else if (MAGICS.VERSION_NUMBER < 50)
        {
            PLATFORM SYSTEM<fgcolor=cAqua>;
         // No S_G1T_HEADER_EX
            local uint32 HEADER_EX_SIZE = 0;
            HEADER_SIZE += 4;
        } 
        else 
        {
            PLATFORM SYSTEM<fgcolor=cAqua>;
            uint32 HEADER_EX_SIZE<bgcolor=cLtBlue>;
            HEADER_SIZE += 8;
        }
        local string S_SYSTEM<hidden=true> = SYSTEM_STR(SYSTEM);
    } S_G1T_HEADER<read=Str("%c%c%c%c v%d - %s",MAGICS.MAGIC[0],MAGICS.MAGIC[1],MAGICS.MAGIC[2],MAGICS.MAGIC[3], MAGICS.VERSION_NUMBER, this.S_SYSTEM)>;

 // Move to start of skip table (can sometimes be 0s)
    FSeek(FileStart + S_G1T_HEADER.TEX_OFFSET);

 // Read offsets. Note: Files without a file size in the header don't have offset values
 // Textures with Alpha Atlas also have wrong offsets as they used an increased BPP instead of increased height
    uint32 S_G1T_SKIP_TABLE[S_G1T_HEADER.TEX_COUNT]<comment="Offsets can be off sometimes", fgcolor=cLtRed>;
    
 // Trackers
    local uint ex_amount<hidden=true> = 0;
    local int i <hidden=true> = 0;
    local int returnto <hidden=true> =  FTell() + S_G1T_HEADER.HEADER_EX_SIZE;
    local int readloc <hidden=true> = returnto;
    local uint64 fileSize<hidden=true> = FileSize();
    
    if(S_G1T_HEADER.HEADER_EX_SIZE != 0)
    {
        local uint ex_size_read<hidden=true> = 0;
        
        struct 
        {
            do{
                S_G1T_HEADER_EX G1T_HEADER_EX;
                ex_size_read += (G1T_HEADER_EX.COUNT * 4) + 4;
                ex_amount += 1;
            } while(ex_size_read < S_G1T_HEADER.HEADER_EX_SIZE);
            
            if(ex_size_read != S_G1T_HEADER.HEADER_EX_SIZE)
            {
                Printf("Extra header size. More data might be present\n");
            }
        }S_G1T_EX_HEADERS;
    }    
    
    for(i = 0; i < S_G1T_HEADER.TEX_COUNT; i++)
    {
        struct S_G1T_TEX 
        {
            local uint32 bUseSwitchSize<hidden=true> = false;
            local uint32 bUsePS5Size<hidden=true> = false;
            
            if( S_G1T_HEADER.SYSTEM == NSwitch )
            {
                bUseSwitchSize = true;
            }
            
            if( S_G1T_HEADER.SYSTEM == PS5 )
            {
                bUsePS5Size = true;
            }
            
            if(S_G1T_HEADER.FILE_SIZE != 0)
            {
                FSeek(S_G1T_HEADER.HEADER_SIZE + (i * 4));
                struct
                {
                 // These are just TEX_EX_TYPE but the size is uint not short so this is just a hack
                    if(bBigEndian)
                    {
                        ubyte  RESERVED_CONSUMED<hidden=true, fgcolor=cYellow, comment="System writes a 1 here once the extras have been consumed">;
                        ubyte  COUNT<hidden=true, bgcolor=cBlack>; 
                        TEX_EX_TYPE TYPE<fgcolor=cAqua>;
                    }
                    else
                    {
                        TEX_EX_TYPE TYPE<fgcolor=cAqua>;
                        ubyte  COUNT<bgcolor=cBlack, hidden=true>; 
                        ubyte  RESERVED_CONSUMED<hidden=true, fgcolor=cYellow, comment="System writes a 1 here once the extras have been consumed">;
                    }
                    
                    if(TYPE == CHANNEL_SWAP)
                    {
                        bUseSwitchSize = false;
                    }
                }S_G1T_TEX_ATTR_HEADER<read=Str("0x%02X - %s", this.TYPE, TEX_EX_STR(this.TYPE)), optimize=false>;
            }
            else
            {
                struct
                {
                    local TEX_EX_TYPE TYPE = 0;
                    local ubyte COUNT = 0;
                    local ubyte RESERVED_CONSUMED<fgcolor=cYellow, comment="System writes a 1 here once the extras have been consumed"> = 0;
                }S_G1T_TEX_ATTR_HEADER<read=Str("0x%02X - %s", this.TYPE, TEX_EX_STR(this.TYPE)), optimize=false>;
            }
            
            FSeek(returnto);
        
            struct 
            {
                S_GT1_LOAD_TYPE KTGL_TEXTURE_TYPE : 4;                 // & 0xF
                ubyte MIP_COUNT: 4;                                    // >> 4
                ubyte KTGL_PIXEL_FORMAT<fgcolor=cAqua, format=hex>;    // + 1
                local TEX_ENUMS tex_format = TEX_FORMS[S_G1T_TEX_HEADER.KTGL_PIXEL_FORMAT * 5];
                byte PACKED_WIDTH: 4,                                  // +2 & 0xF
                     PACKED_HEIGHT: 4<bgcolor=cBlack, fgcolor=cWhite>; // +2 >> 4
                byte PACKED_DEPTH: 4,        // + 3 & 0xF 
                     READ_G1T_HEADER_EX: 4;  // +3 >> 4
                byte KTGL_GD_TEXADDRESSU: 4, // +4 & 0xF
                     KTGL_GD_TEXADDRESSV: 4; // +4 > 4
                byte KTGL_GD_TEXADDRESSW: 4, // +5 & 0xF
                     KTGL_GD_TEXMAGFILTER: 4;  // +5 >> 4
                byte KTGL_GD_TEXMINFILTER: 4,  // +6 & 0xF
                     KTGL_GD_MIPFILTER: 4;  // +6 >> 4
                byte KTGL_GD_ANISO_SAMPLE_NUM: 4,  // +7 & 0xF
                     HAS_TEX_EX_HEADER: 4;   // +7 >> 4
                     
                local uint32 WIDTH =  1 << PACKED_WIDTH;  if(WIDTH  < 1) WIDTH  = 1;
                
                local uint32 HEIGHT = 1 << PACKED_HEIGHT; if(HEIGHT < 1) HEIGHT = 1;
                
                local uint32 DEPTH =  1 << PACKED_DEPTH;  if(DEPTH  < 1) DEPTH  = 1;
                
                local uint32 MIPS = MIP_COUNT < 1 ? 1 : MIP_COUNT;
                
                local int bIsPower2 = true;
                
                if (HAS_TEX_EX_HEADER > 0)
                {
                 // alot here is not read or used
                    uint32 S_G1T_TEX_HEADER_EX_SIZE<bgcolor=cBlack, fgcolor=cWhite>; // 0-4
                    float  Z_SCALE<fgcolor=cYellow, comment="AKA SetMipLodBias">;    // 4-8
                    ushort EX_FACES: 4<comment="aka MINI_MIP_LEVELS">, // +8 & 0xF
                           EX_ARRAY_COUNT : 12<fgcolor=cLtGreen, comment="AKA PlaneCount or MultiSample">;
                    EX_SWIZZLE_TYPE  EX_SWIZZLE;                       //  +10
                    COLOR_SPACE  KTGL_GD_COLOR_SPACE<fgcolor=cAqua>;   // +11 
                 // hard codes the full values if not power of 2
                    if (S_G1T_TEX_HEADER_EX_SIZE == 0x10) 
                    {
                        int EX_WIDTH;
                        if(EX_WIDTH != 0)
                        {
                            WIDTH = EX_WIDTH;
                        }
                        if (!isPowerOfTwo(EX_WIDTH))
                        {
	                        bIsPower2 = false;
                        }
                    }
                    else if (S_G1T_TEX_HEADER_EX_SIZE == 0x14) 
                    {
                        int EX_WIDTH;
                        if(EX_WIDTH != 0)
                        {
                            WIDTH = EX_WIDTH;
                        }
                        int EX_HEIGHT;
                        if(EX_HEIGHT != 0)
                        {
                            HEIGHT = EX_HEIGHT;
                        }
                        if (!isPowerOfTwo(EX_WIDTH) || !isPowerOfTwo(EX_HEIGHT))
                        {
	                        bIsPower2 = false;
                        }
                    }
                 // I havent seen a S_G1T_TEX_HEADER_EX with a size over 12
                    else if (S_G1T_TEX_HEADER_EX_SIZE != 0xC && S_G1T_TEX_HEADER_EX_SIZE > 0x14) 
                    {
                        Printf("Extra tex version on texture index #%d is not zero but data might be missing\n", i);
                    }   
                } 
                else 
                {
                    if(ReadUInt() == 0x0C || ReadUInt() == 0x14) 
                    {
                        Printf("extra tex version is zero but data might be present\n");
                    }
                }
                
                if (KTGL_TEXTURE_TYPE == CUBE)
                {
                    DEPTH = 6;
                }
                
                local uint32 PLANE_COUNT = 1;
                        
                if (KTGL_TEXTURE_TYPE == PLANE_ARRAY)
                {
                    if ( HAS_TEX_EX_HEADER > 0 &&
                         EX_ARRAY_COUNT != 0)
                    {
                        PLANE_COUNT = EX_ARRAY_COUNT;
                    }
                } 
                else if (KTGL_TEXTURE_TYPE == CUBE_ARRAY)
                {
                    if (HAS_TEX_EX_HEADER > 0 &&
                        EX_ARRAY_COUNT != 0)
                    {
                        PLANE_COUNT = EX_ARRAY_COUNT;
                    } 
                }
                else if (KTGL_TEXTURE_TYPE == VOLUME)
                {
                    // sometimes hardcoded to 32
                    if (HAS_TEX_EX_HEADER > 0 &&
                        EX_ARRAY_COUNT != 0)
                    {
                        PLANE_COUNT = 1 << EX_ARRAY_COUNT;
                    }
                }
                
                local uint32 FACES = 1;
            
                if( HAS_TEX_EX_HEADER > 0 && 
                    EX_FACES != 0)
                {
                    FACES = EX_FACES;
                }
                
                if(bIsPower2 == false)
                {
                    bUseSwitchSize = false;
                }
                
                local string str = Str(
                    "0x%02X -%s %d x %d%s%s%s%s%s%s", 
                    KTGL_PIXEL_FORMAT, 
                    LOAD_TYPE_STR(KTGL_TEXTURE_TYPE),
                    WIDTH, 
                    HEIGHT,
                    DEPTH > 1 ? Str(" (depth %d)",DEPTH) : "",
                    MIPS > 1 ? Str(" (%d mips)",MIPS) : "",
                    PLANE_COUNT > 1 ? Str(" (%d layers)",PLANE_COUNT) : "",
                    FACES > 1 ? Str(" (%d faces)",FACES) : "",
                    READ_G1T_HEADER_EX ? Str(" (EX headers x%d)", READ_G1T_HEADER_EX) :"",
                    (HAS_TEX_EX_HEADER && EX_SWIZZLE) ? EX_SWIZZLE_STR(EX_SWIZZLE) : ""
                    );
            } S_G1T_TEX_HEADER<read=this.str, fgcolor=cLtGreen, optimize=false>;
            
            local eASTC_FORMAT ASTC_FORMAT<hidden=true> = -1;
            local int EX_ARRAY_DEPTH<hidden=true> = 0;
         // figure out if an EX header needs to be read
            local int readEX<hidden=true> = S_G1T_TEX_HEADER.READ_G1T_HEADER_EX;
            
            if (readEX > ex_amount)
            {
                readEX = ex_amount;
            }
            
            if( S_G1T_HEADER.HEADER_EX_SIZE == 0 )
            {
                readEX = 0;
            }
            
            if ( S_G1T_HEADER.HEADER_EX_SIZE != 0 &&
                 readEX != 0
	            )
            {
                local int ex_start<hidden=true> = readEX - 1;
                local int ex<hidden=true> = 0;
                
                for (ex = ex_start; ex < ex_amount; ex++)
                {
				    if (S_G1T_EX_HEADERS.G1T_HEADER_EX[ex].CONSUMED == 0 && readEX != 0)
				    {
                        local uint32 return_to<hidden=true> = FTell();
                        FSeek(S_G1T_EX_HEADERS.G1T_HEADER_EX[ex].start);
                        S_G1T_HEADER_EX EX_HEADER;
                        FSeek(return_to);
					    switch (EX_HEADER.TYPE)
					    {
                        case CHANNEL_SWAP:
                            bUseSwitchSize = false;
                            break;
					    case PS4_PLANE_ARRAY:
						    EX_ARRAY_DEPTH = EX_HEADER.ARRAY_DEPTH;
						    break;
					    case PSVITA_PS5_SWIZZLE:
						    break;
					    case ASTC_TYPE:
						    ASTC_FORMAT = EX_HEADER.KT_ASTC_FORMAT;
						    break;
					    default:
						    break;
					    }
                        S_G1T_EX_HEADERS.G1T_HEADER_EX[ex].CONSUMED = 1;
                        readEX--;
				    } 
                }
            }
            
         // ASTC table
            if( (S_G1T_TEX_HEADER.KTGL_PIXEL_FORMAT - 0x7D) < 2 ) // ASTC format
            { 
                local TEX_ENUMS texFormat = ASTC_SUB[ASTC_FORMAT * 5];
                local TEX_ENUMS texSpace =  ASTC_SUB[ASTC_FORMAT * 5 + 1];
                local TEX_ENUMS dataType =  ASTC_SUB[ASTC_FORMAT * 5 + 2];
                local float bitsPerPixel =    MakeBBP(ASTC_SUB[ASTC_FORMAT * 5 + 3]);
                local uint minBytes =       ASTC_SUB[ASTC_FORMAT * 5 + 4];
            } 
            else 
            {
                local TEX_ENUMS texFormat = TEX_FORMS[S_G1T_TEX_HEADER.KTGL_PIXEL_FORMAT * 5];
                local TEX_ENUMS texSpace =  TEX_FORMS[S_G1T_TEX_HEADER.KTGL_PIXEL_FORMAT * 5 + 1];
                local TEX_ENUMS dataType =  TEX_FORMS[S_G1T_TEX_HEADER.KTGL_PIXEL_FORMAT * 5 + 2];
                local float bitsPerPixel =    MakeBBP(TEX_FORMS[S_G1T_TEX_HEADER.KTGL_PIXEL_FORMAT * 5 + 3]);
                local uint minBytes =       TEX_FORMS[S_G1T_TEX_HEADER.KTGL_PIXEL_FORMAT * 5 + 4];
            }
            
            local uint64 offset<hidden=true> = FTell();    
            
            local uint32 MIPS   = S_G1T_TEX_HEADER.MIPS;
            
            local uint32 WIDTH  = S_G1T_TEX_HEADER.WIDTH;
            
            local uint32 HEIGHT = S_G1T_TEX_HEADER.HEIGHT; 
            
            local uint32 DEPTH  = S_G1T_TEX_HEADER.DEPTH; 
            
            local uint32 FACES  = S_G1T_TEX_HEADER.FACES; 
            
            local uint32 PLANE_COUNT = S_G1T_TEX_HEADER.PLANE_COUNT;
            
         // Unsure what this is
            if( EX_ARRAY_DEPTH != 0)
            {
                DEPTH = EX_ARRAY_DEPTH;
            }
            
            local uint32 bCompressedFormat<hidden=true> = 0;
            local uint32 blockWidth<hidden=true> = 1;
            local uint32 blockHeight<hidden=true> = 1;
            local uint32 bHasAlphaAtlas<hidden=true> = 0;
            local uint64 firstMipSize = 0;
            local uint64 expectedBufferSize = 0;
            local uint64 totalTexBufferLen = 0;
            
         // Add special handlers
            switch (S_G1T_TEX_HEADER.KTGL_PIXEL_FORMAT)
            {
                case 0x06: // DXT, ETC, and PVRTC 4bpp
                case 0x07:
                case 0x08:
                case 0x10:
                case 0x11:
                case 0x12:
                case 0x47:
                case 0x48:
                case 0x52:
                case 0x53:
                case 0x56:
                case 0x58:
                case 0x59:
                case 0x5A:
                case 0x5B:
                case 0x5C:
                case 0x5D:
                case 0x5E:
                case 0x5F:
                case 0x60:
                case 0x61:
                case 0x62:
                case 0x63:
                case 0x64:
                case 0x65:
                case 0x66: 
                case 0x71:
                case 0x7A:
                case 0x7B:
                case 0x7C:
                    bCompressedFormat = 1; 
                    blockWidth = 4, blockHeight = 4;
                    break;
                case 0x50: // PVRTC 2bpp
                case 0x51:
                case 0x57:
                    bCompressedFormat = 1;
                    blockWidth = 8, blockHeight = 4;
                    break;
                case 0x7D: // ASTC
                case 0x7E:
                    switch (texFormat)
		            {
		            case 0x93B0: blockWidth = 4;  blockHeight = 4;  break;
		            case 0x93B1: blockWidth = 5;  blockHeight = 4;  break;
		            case 0x93B2: blockWidth = 5;  blockHeight = 5;  break;
		            case 0x93B3: blockWidth = 6;  blockHeight = 5;  break;
		            case 0x93B4: blockWidth = 6;  blockHeight = 6;  break;
		            case 0x93B5: blockWidth = 8;  blockHeight = 5;  break;
		            case 0x93B6: blockWidth = 8;  blockHeight = 6;  break;
		            case 0x93B7: blockWidth = 8;  blockHeight = 8;  break;
		            case 0x93B8: blockWidth = 10; blockHeight = 5;  break;
		            case 0x93B9: blockWidth = 10; blockHeight = 6;  break;
		            case 0x93BA: blockWidth = 10; blockHeight = 8;  break;
		            case 0x93BB: blockWidth = 10; blockHeight = 10; break;
		            case 0x93BC: blockWidth = 12; blockHeight = 10; break;
		            case 0x93BD: blockWidth = 12; blockHeight = 12; break;
		            default: break;
		            }
                    bCompressedFormat = 1;
                    break;
                case 0x6F: // Alpha Atlas formats
                case 0x70:
                 // Offsets on these format are off
                 // bitsPerPixel is adjusted for size but not the height
                    bHasAlphaAtlas = 1;  
                    blockWidth = 4, blockHeight = 4;
                    bCompressedFormat = 1;
                    HEIGHT *= 2;
                    break;
                default:
                    break;
            }
            
            local uint32 pAlignment<hidden=true> = 0;
            
            if( S_G1T_HEADER.SYSTEM == PS4 )
            {
                pAlignment = 4096;
            }
            
         // get the total size of the texture buffer
            if( bUseSwitchSize )
            {
                local uint32 UsedSwitchSize = true;
                firstMipSize = SwitchTextureSizeWithMips(
                    WIDTH,
                    HEIGHT,
                    1,
                    1,
                    1,
                    blockWidth,
                    blockHeight,
                    minBytes,
                    bitsPerPixel,
                    bCompressedFormat,
                    S_G1T_TEX_HEADER.KTGL_TEXTURE_TYPE
                );
                
                totalTexBufferLen  = SwitchTextureSizeWithMips(
                    WIDTH,
                    HEIGHT,
                    DEPTH,
                    MIPS,
                    PLANE_COUNT,
                    blockWidth,
                    blockHeight,
                    minBytes,
                    bitsPerPixel,
                    bCompressedFormat,
                    S_G1T_TEX_HEADER.KTGL_TEXTURE_TYPE
                );
                
                expectedBufferSize = totalTexBufferLen;
            }
            else if(bUsePS5Size)
            {
                // we need the expected size
                if(S_G1T_HEADER.TEX_COUNT == 1)
                {
                    totalTexBufferLen = fileSize - offset;
                }
                else
                {
                 // If there is more than one, check if it's not the last
                    if(i < S_G1T_HEADER.TEX_COUNT - 1)
                    {
                        totalTexBufferLen = (S_G1T_HEADER.TEX_OFFSET + S_G1T_SKIP_TABLE[i+1]) - offset;
                    }
                    else
                    {
                        totalTexBufferLen = fileSize - offset;
                    }
                }
                
                local int64 planeSize = totalTexBufferLen / PLANE_COUNT;
                
                local int64 depthSize = planeSize / DEPTH;
                
                firstMipSize = TextureSizeWithMips(
                    WIDTH,
                    HEIGHT,
                    1,
                    1,
                    1,
                    1,
                    minBytes,
                    blockWidth,
                    blockHeight,
                    bCompressedFormat,
                    bitsPerPixel,
                    pAlignment
                );
                
                expectedBufferSize = totalTexBufferLen;
            }
            else
            {
                firstMipSize = TextureSizeWithMips(
                    WIDTH,
                    HEIGHT,
                    1,
                    1,
                    1,
                    1,
                    minBytes,
                    blockWidth,
                    blockHeight,
                    bCompressedFormat,
                    bitsPerPixel,
                    pAlignment
                );
                
                totalTexBufferLen = TextureSizeWithMips(
                    WIDTH,
                    HEIGHT,
                    DEPTH,
                    MIPS,
                    PLANE_COUNT,
                    FACES,
                    minBytes,
                    blockWidth,
                    blockHeight,
                    bCompressedFormat,
                    bitsPerPixel,
                    pAlignment
                );
                
                expectedBufferSize = totalTexBufferLen;
            }
            
            local string str<hidden=true> = Str(
                "%s -%s %d x %d%s%s%s%s%s%s", 
                FORMAT_STR(S_G1T_TEX_HEADER.KTGL_PIXEL_FORMAT, ASTC_FORMAT), 
                LOAD_TYPE_STR(S_G1T_TEX_HEADER.KTGL_TEXTURE_TYPE),
                WIDTH, 
                HEIGHT,
                DEPTH > 1 ? Str(" (depth %d)",DEPTH) : "",
                MIPS > 1 ? Str(" (%d mips)",MIPS) : "",
                PLANE_COUNT > 1 ? Str(" (%d layers)",PLANE_COUNT) : "",
                FACES > 1 ? Str(" (%d faces)",FACES) : "",
                S_G1T_TEX_HEADER.READ_G1T_HEADER_EX ? Str(" (EX headers x%d)", S_G1T_TEX_HEADER.READ_G1T_HEADER_EX) :"",
                (S_G1T_TEX_HEADER.HAS_TEX_EX_HEADER && S_G1T_TEX_HEADER.EX_SWIZZLE) ? EX_SWIZZLE_STR(S_G1T_TEX_HEADER.EX_SWIZZLE) : ""
                );

            local uint bHasError<hidden=true> = 0;
         // Sanity check on texture data size
            if(S_G1T_HEADER.TEX_COUNT == 1)
            {
             // If there is only one texture, check if there is extra data and meet it
                if(offset + totalTexBufferLen < fileSize)
                {
                    local string errorMessage = Str("Data size of %d but expecting %d.", totalTexBufferLen, fileSize - offset);
                    totalTexBufferLen = fileSize - offset;
                    bHasError = 1;
                }
                else if (offset + totalTexBufferLen > fileSize)
                {
                    local string errorMessage = Str("Data size of %d but only %d left.", totalTexBufferLen, fileSize - offset);
                    totalTexBufferLen = fileSize - offset;
                    bHasError = 1;
                }
            } 
            else 
            {
             // If there is more than one, check if it's not the last
                if(i < S_G1T_HEADER.TEX_COUNT - 1)
                {
                    local uint64 expected_offset<hidden=true> = S_G1T_HEADER.TEX_OFFSET + S_G1T_SKIP_TABLE[i+1];
                    local uint64 dif<hidden=true> = expected_offset - (offset + totalTexBufferLen);
                 // Check if the size matchs the next texture.
                 // if not, adjust based on if over or under.
                    if(expected_offset != offset + totalTexBufferLen)
                    {
                     // If next expected offset is ahead, meet it. But check for max file size.
                        if(expected_offset > offset + totalTexBufferLen)
                        {
                            if(offset + totalTexBufferLen + dif <= fileSize)
                            {
                                local string errorMessage = Str("Data size on texture %d was %d but less than the expected %d.", i, totalTexBufferLen, expected_offset - offset);
                                totalTexBufferLen += dif;
                                bHasError = 1;
                            }
                            else
                            {
                                local string errorMessage = Str("Data size on texture %d was more than remaining file size of %d.", i, offset + totalTexBufferLen);
                                bHasError = 1;
                            }
                        }
                        else
                     // If expected offset is under, warn and continue. But check for max file size.
                        {
                            if(!bHasAlphaAtlas && S_G1T_SKIP_TABLE[i + 1] != 0)
                            {
                                local string errorMessage = Str("Data size on texture %d was more than expected at %d instead of %d.", i, totalTexBufferLen, expected_offset - offset);
                                totalTexBufferLen = expected_offset - offset;
                                bHasError = 1;
                            }
                        }
                    }
                } 
                else 
                {
                 // If this is the last texture, check if there is extra data and meet it
                    if(offset + totalTexBufferLen > fileSize)
                    {
                        local string errorMessage = Str("Data size on texture %d has extra size of %d instead of %d.\n", i, totalTexBufferLen, fileSize - offset);
                        Printf(errorMessage);
                        totalTexBufferLen = fileSize - offset;
                        bHasError = 1;
                    }
                }
            }
            
            if(bHasError)
            {
                str = Str("%s (check error message)", str);
            }

            ubyte TEX_DATA[totalTexBufferLen]<comment="Textures are stored with their mipmaps in this array", format=hex, open=suppress, bgcolor=cDkBlue, fgcolor=cLtAqua>;
            
         // These formats have issues with the skip tables
            if(bHasAlphaAtlas || ((i < (S_G1T_HEADER.TEX_COUNT - 1) && S_G1T_SKIP_TABLE[i+1] == 0)))
            {
                returnto = offset + totalTexBufferLen;
            }
            else if(S_G1T_HEADER.TEX_COUNT != i+1)
            {
                returnto = S_G1T_HEADER.TEX_OFFSET + S_G1T_SKIP_TABLE[i+1];
            }
        }S_G1T_TEX_ENTRY<read=this.str>;
    }
}File<open=true>;